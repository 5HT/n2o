\section{API}

\subsection{Update DOM \bf{wf:update}}
Issues \#update{} action for an element.
It generates jQuery DOM update script and evaluates it.

\subsection{Wire JavaScript \bf{wf:wire}}
Issues \#wire{} action sending JavaScript to be evaluated on the client.

\subsection{Async Processes \bf{wf:comet}}
Creates Erlang processes communicating with the primary page process by sending messages.
For redirecting all updates and wire actions to the page process {\bf wf:flush} should be called.
Usually you send messages to Async processes over N2O message bus.

\subsection{Message Bus {\bf wf:reg} and {\bf wf:send}}
N2O uses GProc process registry for managing async processes pools.
It is used as a PubSub message bus for N2O communications, but later you can switch to robust RabbitMQ.
You can assign a process to the pool with {\bf wf:reg} and send a message to the pool with {\bf wf:send}.

\subsection{Parse URL and Context parameters {\bf wf:q} and {\bf wf:qs}}
These are used to extract URL parameters or read from the process context. {\bf wf:q} extracts variables
from the context stored by controls postbacks and {\bf wf:qs} extracts variables from HTTP forms.

\subsection{Redirects {\bf wf:redirect}}
Redirects are not implemented with HTTP headers but with JavaScript action modifying {\bf window.location}.
This saves login context information and sends it in the first packet upon establishing a WebSocket connection.

\subsection{Session Information {\bf wf:session}}
Stores any session information in ETS tables. Use {\bf wf:user}, {\bf wf:role} for
login and authorization. See {\bf AVZ} library.

\subsection{Bridge information {\bf wf:header} and {\bf wf:cookie}}
You can read and issue cookie and headers information using internal Web-Server routines.
You can also read peer IP with {\bf wf:peer}.

