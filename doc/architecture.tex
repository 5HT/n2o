\section{Erlang Processes}

\subsection{Reduced Latency}
The secret of reducing latency is simple. We try to deliver rendered HTML
as soon as possible and render JavaScript only after WebSocket initialization is complete.
It takes three steps and three Erlang processes to achieve that.

\includeimage{page-lifetime.png}{Page Lifetime}

\paragraph{}
Starting the page lifetime N2O uses HTTP process to serve the first HTML page.
After that it dies and spawns Transition process.
Then the browser initiates WebSocket connections to the similar URL endpoint.
N2O creates persistent WebSocket process and the Transition process dies.

\paragraph{}
Your page could also spawn processes with {\bf wf:comet}.
These are the persistent processes acting like regullar Erlang processes.
It is a usual approach for organizing non-blocking UI for file uploads and time consuming operations.

\subsection{Page Process}
The first HTTP handler only renders HTML. All created
JavaScript actions are stored in the transition process.

\vspace{1\baselineskip}
\begin{lstlisting}
        transition(Actions) ->
            receive {'N2O',Pid} -> Pid ! Actions end.
\end{lstlisting}

\paragraph{}
HTTP handler dies immediately after returning HTML. Transition process
waits for a request from WebSocket handler.

\subsection{Transition Process}
Right after receiving HTML the browser initiates WebSocket connection
thus starting WebSocket handler on the server. After returning
JavaScript actions the Transition process dies and the only process left
running is WebSocket handler. At this point initialization phase is complete.

\subsection{Events Process}
After that all client/server communication is performed over
WebSocket channel. All events coming from the browser are
handled by N2O, which renders elements to HTML and actions to
JavaScript. Each user at any time has only one WebSocket process
per connection.

\subsection{Async Processes}
These are the user processes created with {\bf wf:comet}.
That's a legacy name coming from the times when async technology
was called COMET for XHR channel. Async processes are optional
and are only neededed when you have a UI event taking too much
time to be processed, like gigabyte file uploads. You can create
many Async Processes per user.

\section{Endpoints}
N2O Erlang Processes are instantiated and run by Web Server.
Depending on the Web Server endpoint bindings you can specify
module for HTTP requests handling.

\paragraph{}
N2O comes with three endpoint handlers you can rely on when building your
applications. However you are not limited to use any of these.
You can implement your own endpoint handlers, e.g. for using with
meteor.js or angular.js and providing Erlang back-end event streaming
from server-side. Here is an example of using HTTP, WebSocket and
REST endpoint handlers with Cowboy Web Server.

\vspace{1\baselineskip}
\begin{lstlisting}
    {"/rest/:bucket", n2o_rest, []},
    {"/rest/:bucket/:key", n2o_rest, []},
    {"/rest/:bucket/:key/[...]", n2o_rest, []},
    {"/ws/[...]", bullet_handler, [{handler, n2o_bullet}]},
    {'_', n2o_cowboy, []}
\end{lstlisting}

\subsection{HTML Pages over HTTP}
This handler is used for serving initial dynamic HTML page.
In case you are serving static HTML content this handler is
not included into the running stack. {\bf {n2o}\_{cowboy}} is
a default HTML page handler.

\paragraph{}
On initial page load {\bf {wf}\_{core}:run} is started during
which {\bf {wf}\_{core}:render} proceeds by calling {\bf Module:main} which
is selected by the routing handler.

\subsection{JavaScript Events over WebSocket}
JavaScript handler shares the same router information as the
HTML handler because during its initial phase the same chain
of N2O handlers is called.

\paragraph{}
This handler knows how to deal with XHR and WebSocket requests.
{\bf {n2o}\_{bullet}} is a default JavaScript event handler
based on Bullet library created by LoÃ¯c Hoguin.

\newpage
\subsection{HTTP API over REST}
REST handler's request context initizlization differs for the one
used by HTML and JavaScript handlers. N2O handler chains are not
applied to REST requests. {\bf {n2o}\_{rest}} is a default REST
handler based on FarWest framework.

\vspace{1\baselineskip}
\begin{lstlisting}
    {"/rest/:bucket", n2o_rest, []},
    {"/rest/:bucket/:key", n2o_rest, []},
    {"/rest/:bucket/:key/[...]", n2o_rest, []},
\end{lstlisting}

\vspace{1\baselineskip}
\begin{lstlisting}
    -module(users).
    -compile(export_all).
    -record(user, {id,name,email,tokens}).

    -define(USERS, [#user{id="maxim",email="maxim@synrc.com"},
                    #user{id="doxtop",email="doxtop@synrc.com"},
                    #user{id="roman",email="roman@github.com"}]).

    init() -> ets:new(users, [named_table,{keypos,#user.id}]),
              ets:insert(users, ?USERS).
    get([]) -> ets:foldl(fun(C,Acc) -> [C|Acc] end,[],users);
    get(Id) -> ets:lookup(users,Id).
    delete(Id) -> ets:delete(users,Id).
    put(User=#user{}) -> ets:insert(users,User).
    exists(Id) -> ets:member(users,Id).
    to_html(User=#user{}) ->
        [ <<"<tr><td>">>,
          coalesce(User#user.id),<<"</td><td>">>,
          coalesce(User#user.email),<<"</td><td>">>,
          coalesce(User#user.name),<<"</td></tr">>].

    coalesce(Name) -> 
        case Name of 
            undefined -> <<>>;
            A -> list_to_binary(A) end.
\end{lstlisting}
\vspace{1\baselineskip}

\section{Handlers}
HTML and JavaScript Web Server HTTP handlers share the same system
of context initialization. 

\vspace{1\baselineskip}
\begin{lstlisting}
        init_context(Req) -> #context{
            actions=[], module=index, path=[],
            req=Req, params=[], session=undefined,
            handlers= [ {'query', wf:config('query', n2o_query_handler)},
                        {session, wf:config(session, n2o_session_handler)},
                        {route,   wf:config(route, n2o_route_handler)} ]}.
\end{lstlisting}
\vspace{1\baselineskip}

Chain of three N2O handlers is called
on each HTTP request. You can redefine any of them.

\vspace{1\baselineskip}
\begin{lstlisting}[caption={wf}\_{core}:fold/3]
    fold(Fun,Handlers,Ctx) ->
        lists:foldl(fun({_,Module},Ctx1) ->
            {ok,_,NewCtx} = Module:Fun([],Ctx1),
            NewCtx end,Ctx,Handlers).
\end{lstlisting}
\vspace{1\baselineskip}

\subsection{Query}
Query Handler parses URL query and HTTP form information from HTTP request.

\subsection{Session}
Session Handler manages key-value in-memory database ETS table that can be accessed.

\newpage
\subsection{Router}
You can specify routing table with application config:

\vspace{1\baselineskip}
\begin{lstlisting}
         {n2o, [{route,custom_router}]}
\end{lstlisting}
\vspace{1\baselineskip}

Remember that routing handler should be kept very simple because it
influences overal initial page load latency and HTTP capacity.

\vspace{1\baselineskip}
\begin{lstlisting}
        -module(custom_router).
        -include_lib("n2o/include/wf.hrl").
        -compile(export_all).
        finish(State, Ctx) -> {ok, State, Ctx}.
        init(State, Ctx) -> 
            Path = wf:path(Ctx#context.req),
            {Module, PathInfo} = route(Path),
            {ok, State, Ctx#context{path=PathInfo,module=Module}}.

        route(<<"/">>) -> {index, []};
        route(<<"/index">>) -> {index, []};
        route(<<"/login">>) -> {login, []};
        route(<<"/ws/">>) -> {index, []};
        route(<<"/ws/index">>) -> {index, []};
        route(<<"/ws/login">>) -> {login, []};
        route(<<"/favicon.ico">>) -> {static_file, []};
        route(_) -> {index, []}.
\end{lstlisting}
