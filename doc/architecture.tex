\section{Erlang Processes}

\subsection{Reduced Latency}
The secret of reduced latency is simple. We try to deliver rendered HTML
as soon as possible and render JavaScript only after WebSocket initialization.
We use three steps and three erlang processes to achieve that.

\includeimage{page-lifetime.png}{Page Lifetime}

\paragraph{}
During lifetime N2O uses HTTP process for serving first HTML page after that it dies
and spawns Transition process. After that browser initiates WebSocket connections
to the similar URL endpoint and N2O creates persistent WebSocket process and
Transition Process dies.

\paragraph{}
Also your page could spawn processes with {\bf wf:comet}. They are also persistent
processes that act as regullar Erlang processes. It is a common way to organize
non-blocking UI for things like file uploads and long-term operations.

\subsection{Page Process}
In the first HTTP handler we only render HTML and all created
javascript actions are stored in transition process.

\vspace{1\baselineskip}
\begin{lstlisting}
        transition(Actions) ->
            receive {'N2O',Pid} -> Pid ! Actions end.
\end{lstlisting}

\paragraph{}
HTTP handler dies immediately after returning HTML. Transition process
waits for request from WebSocket handler.

\subsection{Transition Process}
Just after receiving HTML browser initiates WebSocket connection
and this starts WebSocket handler on the server. After returning
javascript actions transition process dies and only WebSocket handler stays.
At this point initialization phase is done.

\subsection{Events Process}
After that all client/server communication is done via
WebSocket channel. All events that come from the browser are
handled by N2O, which renders elements to HTML and actions to
JavaScript. Each user at a time has only one WebSocket process
per connection.

\subsection{Async Processes}
These are user processes which are created by {\bf wf:comet}.
This is the legacy name taken from times where async technology
was called COMET for XHR channel. Async processes are optional
and needed only when you have UI event which takes a lot of
time to proceed like gigabyte file uploads, etc. You can create
many Async Processes per user.

\section{Endpoints}
N2O Erlang Processes are instantiated and driven by Web Server.
Depending of Web Server endpoint bindings you can specify
module wich handles the HTTP requests.

\paragraph{}
N2O comes with three endpoint handlers you could rely on while building
applications. However you are not limited to use only this set,
you can also write your own endpoint handlers, e.g. for usage with
meteor.js or angular.js and providing Erlang back-end event streming
from server-side. Here is an example of using HTTP, WebSocket and
REST endpoint handlers with Cowboy Web Server.

\vspace{1\baselineskip}
\begin{lstlisting}
    {"/rest/:bucket", n2o_rest, []},
    {"/rest/:bucket/:key", n2o_rest, []},
    {"/rest/:bucket/:key/[...]", n2o_rest, []},
    {"/ws/[...]", bullet_handler, [{handler, n2o_bullet}]},
    {'_', n2o_cowboy, []}
\end{lstlisting}

\subsection{HTML Pages over HTTP}
This handler is used for serving initial dynamic HTML page.
In case you are serving static HTML content this handler is
not included into running stack. {\bf {n2o}\_{cowboy}} is
default HTML page handler.

\paragraph{}
On initial page load {\bf {wf}\_{core}:run} is started during
which {\bf {wf}\_{core}:render} proceed by calling {\bf Module:main} which
is selected by routing handler.

\subsection{JavaScript Events over WebSocket}
JavaScript handler shares the same router information as the
HTML handler because during its initial phase same chain
of N2O handlers are called.

\paragraph{}
This handler knows how to deal with XHR and WebSocket requests.
{\bf {n2o}\_{bullet}} is default JavaScript event handler
and is based on Bullet library created by LoÃ¯c Hoguin.

\newpage
\subsection{HTTP API over REST}
REST handler uses different request context initizlization
from HTML and JavaScript hanlder. N2O handler chains are not
applied to REST requests. {\bf {n2o}\_{rest}} is default REST
handler and is based on FarWest framework.

\vspace{1\baselineskip}
\begin{lstlisting}
    {"/rest/:bucket", n2o_rest, []},
    {"/rest/:bucket/:key", n2o_rest, []},
    {"/rest/:bucket/:key/[...]", n2o_rest, []},
\end{lstlisting}

\vspace{1\baselineskip}
\begin{lstlisting}
    -module(users).
    -compile(export_all).
    -record(user, {id,name,email,tokens}).

    -define(USERS, [#user{id="maxim",email="maxim@synrc.com"},
                    #user{id="doxtop",email="doxtop@synrc.com"},
                    #user{id="roman",email="roman@github.com"}]).

    init() -> ets:new(users, [named_table,{keypos,#user.id}]),
              ets:insert(users, ?USERS).
    get([]) -> ets:foldl(fun(C,Acc) -> [C|Acc] end,[],users);
    get(Id) -> ets:lookup(users,Id).
    delete(Id) -> ets:delete(users,Id).
    put(User=#user{}) -> ets:insert(users,User).
    exists(Id) -> ets:member(users,Id).
    to_html(User=#user{}) ->
        [ <<"<tr><td>">>,
          coalesce(User#user.id),<<"</td><td>">>,
          coalesce(User#user.email),<<"</td><td>">>,
          coalesce(User#user.name),<<"</td></tr">>].

    coalesce(Name) -> 
        case Name of 
            undefined -> <<>>;
            A -> list_to_binary(A) end.
\end{lstlisting}
\vspace{1\baselineskip}

\section{Handlers}
HTML and JavaScript Web Server HTTP handlers share the same system
of context initialization. 

\vspace{1\baselineskip}
\begin{lstlisting}
        init_context(Req) -> #context{
            actions=[], module=index, path=[],
            req=Req, params=[], session=undefined,
            handlers= [ {'query', wf:config('query', n2o_query_handler)},
                        {session, wf:config(session, n2o_session_handler)},
                        {route,   wf:config(route, n2o_route_handler)} ]}.
\end{lstlisting}
\vspace{1\baselineskip}

Chain of three N2O handlers is called
on each HTTP request. You can redefine each of them.

\vspace{1\baselineskip}
\begin{lstlisting}[caption={wf}\_{core}:fold/3]
    fold(Fun,Handlers,Ctx) ->
        lists:foldl(fun({_,Module},Ctx1) ->
            {ok,_,NewCtx} = Module:Fun([],Ctx1),
            NewCtx end,Ctx,Handlers).
\end{lstlisting}
\vspace{1\baselineskip}

\subsection{Query}
Query Handler parses URL query and HTTP form information on HTTP request.

\subsection{Session}
Session Handler manages key-value in-memory database ETS table which can be accessed.

\newpage
\subsection{Router}
You could specify routing table with application config:

\vspace{1\baselineskip}
\begin{lstlisting}
         {n2o, [{route,custom_router}]}
\end{lstlisting}
\vspace{1\baselineskip}

Remember that routing handler should be kept very simple because it
influences overal initial page load latency and HTTP capacity.

\vspace{1\baselineskip}
\begin{lstlisting}
        -module(custom_router).
        -include_lib("n2o/include/wf.hrl").
        -compile(export_all).
        finish(State, Ctx) -> {ok, State, Ctx}.
        init(State, Ctx) -> 
            Path = wf:path(Ctx#context.req),
            {Module, PathInfo} = route(Path),
            {ok, State, Ctx#context{path=PathInfo,module=Module}}.

        route(<<"/">>) -> {index, []};
        route(<<"/index">>) -> {index, []};
        route(<<"/login">>) -> {login, []};
        route(<<"/ws/">>) -> {index, []};
        route(<<"/ws/index">>) -> {index, []};
        route(<<"/ws/login">>) -> {login, []};
        route(<<"/favicon.ico">>) -> {static_file, []};
        route(_) -> {index, []}.
\end{lstlisting}
